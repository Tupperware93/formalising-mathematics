import topology.subset_properties

variables (X Y : Type) [topological_space X] [topological_space Y] (f : X → Y)

open filter set

open_locale filter -- for 𝓟
open_locale topological_space -- for 𝓝 

/-

## Neighbourhood filters

If `α` is a topological space and `a : α` then `𝓝 a` is the following
filter on `α`: `X ∈ 𝓝 a` if and only if `X` contains an open neighbourhood
of `a`, or equivalently if `a` is in the interior of `X`. You should think
of `𝓝 a` as the "generalised subset" of `X` corresponding to an infinitesimally
small open neighbourhood of `a`. 

Let's use the API for interior and closure, and check that `𝓝 a` is a filter.

Useful stuff from the topological space API:
`interior_univ : interior univ = univ`
`mem_univ x : x ∈ univ`
`interior_mono : s ⊆ t → interior s ⊆ interior t`
and guess what this is called:
`??? : interior (s ∩ t) = interior s ∩ interior t`
If you don't know how to #check your guess, ask me!
-/

variables {α : Type*} [topological_space α]

open set

-- neighbourhood filter 𝓝 a on α 
example (a : α): filter α :=
{ sets := {X : set α | a ∈ interior X},
  univ_sets := begin
    use univ,
    simp,
  end,
  sets_of_superset := begin
    rintros x y ⟨X', ⟨hX1, hX2⟩ , haX⟩ hxy,
    use X',
    use ⟨hX1, subset.trans hX2 hxy⟩,
    exact haX,
  end,
  inter_sets := begin
    rintros x y ⟨X', ⟨hX1, hX2⟩ , haX⟩ ⟨Y, ⟨hY1, hY2⟩ , haY⟩,
    use X' ∩  Y,
    use is_open_inter hX1 hY1,
    intros a ha,
    cases ha with haX haY,
    exact ⟨hX2 haX, hY2 haY⟩,
    exact ⟨haX, haY⟩,    
  end }

/-

## Cluster points. 

A cluster point `a : α` of a filter `F : filter α` on a topological
space should be thought of as a point in the closure of the "generalised set"
corresponding to `F`. Here's the formal definition.

A cluster point of a filter `F : filter α` (also known as an accumulation
point or a limit point) is `x : α` such that `𝓝 x ⊓ F ≠ ⊥`. The picture
is that the intersection of the generalised set `F` and the infinitesimal
open neighbourhood `𝓝 x` of `x` is nonempty, or in other words that `x`
is in some kind of "closure" of `F`. Let's go through the notation more carefully
though, to try and figure out what it means. Recall that the order on filters is
upside-down, so `𝓝 x ⊓ F` means the filter generated by `F` and the
neighbourhoods of `x`, and `⊥` is the filter which contains every subset.
So this boils down to saying that there do not exist sets `A ∈ 𝓝 x` and `B ∈ F`
such that `A ∩ B = ∅`, or, in other words, every element of the filter
intersects every neighbourhood of `x`. To give an example, if `S` is any subset
of `α` then the cluster points of `𝓟 S` are just the points `x` such that any
open set containing `x` meets `S`, or equivalently that `x` is in the
closure of `S`.

The below lemma is called `cluster_pt.mono` in mathlib. The picture is
that if `F` and `G` are generalised subsets of a topological space
and `F ⊆ G`, then `closure F ⊆ closure G`. You can prove it by
using `cluster_pt.mono` of course, but why not give a direct proof
yourself? Start by rewriting `cluster_pt_iff`, which translates down
the definition of `cluster_pt` to a purely set-theoretic one not
involving `⊓`.

-/

example {x : α} {F G : filter α} (hxF : cluster_pt x F) (hFG : F ≤ G) :
  cluster_pt x G :=
begin
  rw cluster_pt_iff at *,
  intros X hX V hV,
  apply hxF hX,
  rw le_def at *,
  apply hFG,
  apply hV,
end

/-

## Compactness

The actual definition of `is_compact` in mathlib: A subset `S` of a topological
space `α` is *compact* if for every filter `F ≠ ⊥` such that `S ∈ F`,
there exists `a : α` such that every set of `F` also meets every
neighborhood of `a`. In pictures -- `S` is compact iff the closure of every
non-empty generalised subset `F ⊆ S` contains an element of `S`. I'm not
too sure this picture helps much (at least, it doesn't help me too much).
Somehow noncompactness results in generalised subsets which are
"on the boundary of `S`" but which don't intersect a small neighbourhood of
any elements of `S`. Perhaps it's best not to worry about this exotic
definition right now -- or perhaps one of you can explain it to me. Of course
it's equivalent to the usual definition of compactness, but we won't prove this.

So here is another proof that a closed subset of a compact space is compact.
As before, we prove the more general assertion that if `α` is any topological
space then the intersection of a compact subset of `α` and a closed subset
of `α` is a compact subset of `α`.

Here's the actual definition in mathlib:

`def is_compact (s : set α) := ∀ ⦃f⦄ [ne_bot f], f ≤ 𝓟 s → ∃a∈s, cluster_pt a f`

Note that `ne_bot f` is in square brackets, which means that the type
class inference system is supposed to supply it. We will explicitly
add this fact into the type class inference system with `haveI` below.

Now here's a suggestion for a proof. Say `S` is compact and `C` is closed.
Say `F` is a non-bot filter with `F ≤ 𝓟 (S ∩ C)`. 
First show that by compactness of `S`, we can find a cluster point
`a` for `F` in `S`. Now show that this cluster point is in `C` too, 
because `C` is closed. You might find 

`is_closed.closure_eq : is_closed C → closure C = C`

useful, and also

`mem_closure_iff_cluster_pt : a ∈ closure S ↔ cluster_pt a (𝓟 S)`

-/

lemma closed_of_compact (S : set X) (hS : is_compact S)
  (C : set X) (hC : is_closed C) : is_compact (S ∩ C) :=
begin
  -- assume `F` is a filter which is not `⊥`, and `≤` is the principal
  -- filter on `S ∩ C` (i.e. which contains `S ∩ C`). We need to find a
  -- cluster point for `F` which is in `S ∩ C`.
  intros F hnF hFSC,
  -- Let's tell the type class inference system about `hnf : f.ne_bot`
  haveI := hnF,
  -- see if you can take it from here.
  have h1 : ∃ a ∈ S, cluster_pt a F :=
  begin
    have H : 𝓟 (S ∩ C) ≤ 𝓟 (S) := 
    begin
      refine principal_mono.mpr _,
      simp,
    end,
    specialize hS (le_trans hFSC H),
    assumption,
  end,

  obtain ⟨h, h', h''⟩ := h1,
  use h,
  use h',

  have H' : cluster_pt h (𝓟 (S ∩ C)) :=
  begin
    refine cluster_pt.mono _ _,
    exact F,
    exact h'',
    exact hFSC,
  end,  

  rw ←mem_closure_iff_cluster_pt at *,
  have H'' : closure (S ∩ C) ⊆ closure C :=
  begin
    refine closure_mono _,
    simp,
  end,
  rw (is_closed.closure_eq hC) at *,
  exact H'' H',
end


